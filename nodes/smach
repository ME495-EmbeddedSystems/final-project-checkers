#!/usr/bin/env python
"""
DESCRIPTION:


SUBSCRIBERS:

SERVICES:
"""

import rospy
import smach
import smach_ros
import actionlib
from checkers.msg import PickPlaceAction, PickPlaceGoal
import baxter_interface
from checkers.play_checkers import CheckersAI
from std_msgs.msg import String
from baxter_interface import Gripper, CHECK_VERSION


class Client():
    def __init__(self):
        # Initialise CheckersAI Class
        self.chai = CheckersAI()
        # Enable Baxter
        baxter_interface.robot_enable.RobotEnable()
        rospy.loginfo("Baxter Enabled!")
        # Initialise pick place client
        self.pp_client = actionlib.SimpleActionClient('pick_place_as',
                                                      PickPlaceAction)
        # Wait for server response
        self.pp_client.wait_for_server()
        rospy.loginfo("Server Initialised!")
        # Initialise goal msg
        self.pp_goal = PickPlaceGoal()

        # Board State Subscriber
        self.count = 0
        self.board_state = ""
        self.subBS = rospy.Subscriber('Board_State',
                                      String,
                                      self.callback_BS,
                                      queue_size=1)

        # Board Dictionary from Top Left
        self.SW = 0.0559
        self.board_dict = {
            0: [self.SW * 6.5, self.SW * 6.5],
            1: [self.SW * 6.5, self.SW * 5.5],
            2: [self.SW * 6.5, self.SW * 4.5],
            3: [self.SW * 6.5, self.SW * 3.5],
            4: [self.SW * 6.5, self.SW * 2.5],
            5: [self.SW * 6.5, self.SW * 1.5],
            6: [self.SW * 6.5, self.SW * 0.5],
            7: [self.SW * 6.5, self.SW * -0.5],
            8: [self.SW * 5.5, self.SW * 6.5],
            9: [self.SW * 5.5, self.SW * 5.5],
            10: [self.SW * 5.5, self.SW * 4.5],
            11: [self.SW * 5.5, self.SW * 3.5],
            12: [self.SW * 5.5, self.SW * 2.5],
            13: [self.SW * 5.5, self.SW * 1.5],
            14: [self.SW * 5.5, self.SW * 0.5],
            15: [self.SW * 5.5, self.SW * -0.5],
            16: [self.SW * 4.5, self.SW * 6.5],
            17: [self.SW * 4.5, self.SW * 5.5],
            18: [self.SW * 4.5, self.SW * 4.5],
            19: [self.SW * 4.5, self.SW * 3.5],
            20: [self.SW * 4.5, self.SW * 2.5],
            21: [self.SW * 4.5, self.SW * 1.5],
            22: [self.SW * 4.5, self.SW * 0.5],
            23: [self.SW * 4.5, self.SW * -0.5],
            24: [self.SW * 3.5, self.SW * 6.5],
            25: [self.SW * 3.5, self.SW * 5.5],
            26: [self.SW * 3.5, self.SW * 4.5],
            27: [self.SW * 3.5, self.SW * 3.5],
            28: [self.SW * 3.5, self.SW * 2.5],
            29: [self.SW * 3.5, self.SW * 1.5],
            30: [self.SW * 3.5, self.SW * 0.5],
            31: [self.SW * 3.5, self.SW * -0.5],
            32: [self.SW * 2.5, self.SW * 6.5],
            33: [self.SW * 2.5, self.SW * 5.5],
            34: [self.SW * 2.5, self.SW * 4.5],
            35: [self.SW * 2.5, self.SW * 3.5],
            36: [self.SW * 2.5, self.SW * 2.5],
            37: [self.SW * 2.5, self.SW * 1.5],
            38: [self.SW * 2.5, self.SW * 0.5],
            39: [self.SW * 2.5, self.SW * -0.5],
            40: [self.SW * 1.5, self.SW * 6.5],
            41: [self.SW * 1.5, self.SW * 5.5],
            42: [self.SW * 1.5, self.SW * 4.5],
            43: [self.SW * 1.5, self.SW * 3.5],
            44: [self.SW * 1.5, self.SW * 2.5],
            45: [self.SW * 1.5, self.SW * 1.5],
            46: [self.SW * 1.5, self.SW * 0.5],
            47: [self.SW * 1.5, self.SW * -0.5],
            48: [self.SW * 0.5, self.SW * 6.5],
            49: [self.SW * 0.5, self.SW * 5.5],
            50: [self.SW * 0.5, self.SW * 4.5],
            51: [self.SW * 0.5, self.SW * 3.5],
            52: [self.SW * 0.5, self.SW * 2.5],
            53: [self.SW * 0.5, self.SW * 1.5],
            54: [self.SW * 0.5, self.SW * 0.5],
            55: [self.SW * 0.5, self.SW * -0.5],
            56: [self.SW * -0.5, self.SW * 6.5],
            57: [self.SW * -0.5, self.SW * 5.5],
            58: [self.SW * -0.5, self.SW * 4.5],
            59: [self.SW * -0.5, self.SW * 3.5],
            60: [self.SW * -0.5, self.SW * 2.5],
            61: [self.SW * -0.5, self.SW * 1.5],
            62: [self.SW * -0.5, self.SW * 0.5],
            63: [self.SW * -0.5, self.SW * -0.5]
        }

    def feedback_pp(self, msg):
        # do something here
        rospy.loginfo("Completed Moves: {}".format(msg))

    def callback_BS(self, msg):
        if self.count == 0:
            self.board_state = msg.data
            self.count = 1


class SETUP(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self, outcomes=['initialised'])
        # Initialise client
        self.client = client

    def setup_goal(self,
                   pick_goal=[0, 0],
                   place_goal=[0, 0],
                   home=False,
                   calibrate=False,
                   camera_view=False,
                   camera_home=False):
        """ DESCRIPTION

            Args:

            Returns:
        """
        self.client.pp_goal.home = home
        self.client.pp_goal.pick_goal = pick_goal
        self.client.pp_goal.place_goal = place_goal
        self.client.pp_goal.calibrate = calibrate
        self.client.pp_goal.camera_view = camera_view
        self.client.pp_goal.camera_home = camera_home
        self.client.pp_client.send_goal(self.client.pp_goal)
        self.client.pp_client.wait_for_result()
        if home is True:
            rospy.loginfo("Returned to Home Position")

        elif calibrate is True:
            rospy.loginfo("Calibrated")

        elif camera_view is True:
            rospy.loginfo("Camera at View Position")

        elif camera_home is True:
            rospy.loginfo("Camera at Home Position")

    def execute(self, userdata):
        rospy.loginfo('Initialising...')
        # Call Camera Calibration
        # Make sure pp arm at home
        self.setup_goal(home=True)
        # Put camera at view
        # self.setup_goal(camera_view=True)
        # Input in case user wants to perform manual calibration
        left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        left_gripper.reboot()
        # Calibrate Gripper
        left_gripper.calibrate()
        # Open Gripper
        left_gripper.close()
        rospy.loginfo("Hit enter when the camera arm is at the desired pose")
        raw_input()
        self.setup_goal(calibrate=True)
        rospy.sleep(1)
        # Return camera home
        self.setup_goal(camera_home=True)

        # Display on screen: please set up the board and
        # hit enter when ready
        rospy.loginfo('Please set up the board and hit enter when ready')
        raw_input()

        return 'initialised'


class PICKCOLOR(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self, outcomes=['red', 'black'])
        # Initialise client
        self.client = client

    def execute(self, userdata):
        rospy.loginfo('Pick a color for BAXTER, p or g')
        # Call AS to determine if baxter is red or black
        # userdata.client.pc_client.send goal
        # userdata.client.pc_client.wait_for_result()
        # result = userdata.client.pc_client.get_result()
        color = raw_input()
        if color == 'p':
            rospy.loginfo("BAXER IS {}".format("Purple"))
            self.client.chai.board.baxter_color = "black"
            self.client.chai.board.not_baxter = "red"
            return 'black'
        else:
            rospy.loginfo("BAXER IS {}".format("Green"))
            self.client.chai.board.baxter_color = "red"
            self.client.chai.board.not_baxter = "black"
            return 'red'


class WAIT(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['play'])

    def execute(self, userdata):
        rospy.loginfo('Press Enter to end your turn')
        raw_input()

        return 'play'


class MYTURN(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self,
                             outcomes=['move', 'exit'],
                             output_keys=['moves'])
        # Initialise client
        self.client = client

    def pp_goal(self,
                pick_goal=[0, 0],
                place_goal=[0, 0],
                home=False,
                calibrate=False,
                camera_view=False,
                camera_home=False):
        """ DESCRIPTION

            Args:

            Returns:
        """
        self.client.pp_goal.pick_goal = pick_goal
        self.client.pp_goal.place_goal = place_goal
        self.client.pp_goal.home = home
        self.client.pp_goal.calibrate = calibrate
        self.client.pp_goal.camera_view = camera_view
        self.client.pp_goal.camera_home = camera_home

        if home is True or calibrate is True or camera_view is True or camera_home is True:
            self.client.pp_client.send_goal(self.client.pp_goal)
            self.client.pp_client.wait_for_result()
            if home is True:
                rospy.loginfo("Returned to Home Position")
            elif calibrate is True:
                rospy.loginfo("Calibrated")
            elif camera_view is True:
                rospy.loginfo("Camera at View Position")
            elif camera_home is True:
                rospy.loginfo("Camera at Home Position")

        else:
            self.client.pp_client.send_goal(
                self.client.pp_goal, feedback_cb=self.client.feedback_pp)
            self.client.pp_client.wait_for_result()
            cart = self.client.pp_client.get_result()
            rospy.loginfo("Cartesian path {}".format(cart))

    def execute(self, userdata):
        rospy.loginfo("Moving Camera to View")
        # Call AS to put camera at view position
        self.pp_goal(camera_view=True)
        rospy.sleep(1)
        rospy.loginfo('Reading board state')
        # Call AS to read board state and feed data to logic
        # SUBSCRIBE TO \Board_State and get board state
        # Read until valid board state (at least 2 pcs)
        str_count = 0
        while str_count < 2:
            self.count = 0
            rospy.sleep(0.1)
            list_from_cam = self.client.board_state
            str_check = list_from_cam.split(" ")
            for item in str_check:
                if item != "empty":
                    str_count += 1

        rospy.loginfo("LIST")
        rospy.loginfo(list_from_cam)
        move_list = self.client.chai.give_command(list_from_cam)
        # Output moves to MOVE state
        userdata.moves = move_list
        rospy.loginfo("Let's see how well you played...")
        # Call AS to put camera at home position
        self.pp_goal(camera_home=True)

        # Call logic function to determine win/lose
        # end_game = self.client.chai.game_over
        # winner = self.client.chai.winner
        end_game = False
        status = "win"
        if end_game is True:
            if status == "win":
                rospy.loginfo("Ha! I win!")
            elif status == "draw":
                rospy.loginfo("Everyone is a winner!")
            elif status == "lose":
                rospy.loginfo("You win :(")
            return 'exit'
        else:
            return 'move'


class MOVE(smach.State):
    # Place Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self,
                             outcomes=['wait', 'exit'],
                             input_keys=['moves'])
        # Initialise client
        self.client = client

    def pp_goal(self,
                pick_goal=[0, 0],
                place_goal=[0, 0],
                home=False,
                calibrate=False,
                camera_view=False,
                camera_home=False):
        """ DESCRIPTION

            Args:

            Returns:
        """
        self.client.pp_goal.pick_goal = pick_goal
        self.client.pp_goal.place_goal = place_goal
        self.client.pp_goal.home = home
        self.client.pp_goal.calibrate = calibrate
        self.client.pp_goal.camera_view = camera_view
        self.client.pp_goal.camera_home = camera_home

        if home is True or calibrate is True or camera_view is True or camera_home is True:
            self.client.pp_client.send_goal(self.client.pp_goal)
            self.client.pp_client.wait_for_result()
            if home is True:
                rospy.loginfo("Returned to Home Position")
            elif calibrate is True:
                rospy.loginfo("Calibrated")
            elif camera_view is True:
                rospy.loginfo("Camera at View Position")
            elif camera_home is True:
                rospy.loginfo("Camera at Home Position")

        else:
            self.client.pp_client.send_goal(
                self.client.pp_goal, feedback_cb=self.client.feedback_pp)
            self.client.pp_client.wait_for_result()
            cart = self.client.pp_client.get_result()
            rospy.loginfo("Cartesian path {}".format(cart))

    def execute(self, userdata):
        # Call AS to perform pick-place per move
        # FOR EACH BAXTER MOVE
        moves = userdata.moves
        # Pick and Place always 0 and 1
        pick_index = moves[0]
        place_index = moves[1]
        # pick_index = 62
        # place_index = 63
        pick_goal = self.client.board_dict[pick_index]
        place_goal = self.client.board_dict[place_index]
        home = False
        self.pp_goal(pick_goal, place_goal, home)

        # Call AS to perform pick-place per discard
        # FOR EACH BAXTER DISCARD
        # Pieces to discard start from 2
        rospy.loginfo("MOVES")
        rospy.loginfo(moves)
        if len(moves) > 2:
            for i in range(2, len(moves)):
                discard_index = moves[i]
                pick_goal = self.client.board_dict[discard_index]
                place_goal = [0.3, -0.3]
                home = False
                self.pp_goal(pick_goal, place_goal, home)

        # Call AS to go home to clear board for camera
        self.pp_goal(home=True)

        # Call logic function to determine win/lose
        # end_game = self.client.chai.game_over
        # winner = self.client.chai.winner
        end_game = False
        status = "win"
        if end_game is True:
            if status == "win":
                rospy.loginfo("Ha! I win!")
            elif status == "draw":
                rospy.loginfo("Everyone is a winner!")
            elif status == "lose":
                rospy.loginfo("You win :(")
            return 'exit'
        else:
            return 'wait'


class SHUTDOWN(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['end'])

    def execute(self, userdata):
        rospy.loginfo('Disabling Baxter...')
        # Disable Baxter
        baxter_interface.robot_enable.RobotDisable()
        rospy.loginfo("Baxter Disabled!")

        return 'end'


def main():
    """ The Main Function

        Call Client to initialise action servers

        State Machine Hierarchy:
        (AS means Action Server, outcomes are in square brackets)

        STATE_MACHINE

        - Setup (AS: Calibrate Camera - run until successful calibration
          --> AS: Calibrate EE-Board transform -->
          DISPLAY: Ask human to put pieces on board (raw_input) [initialised])

        - AS: Baxter_Red_or_Black (two outcomes)
            -- Black: [wait] --> Wait raw_input()
            -- Red: [play] --> MyTurn
        - Wait raw_input() [play] --> MyTurn
        - MyTurn (AS: Read Board [check] --> Logic_win_lose_draw (two outcomes)
            -- [wld] Win/Lose/Draw [exit] --> ShutDown [end]
            -- [move] Next_Move [pickplace] --> AS: PickPlace [check]
                --> Logic_win_lose_draw (two outcomes)
                    -- [wld] Win/Lose/Draw [exit] --> ShutDown ([end]
                    -- [wait] Wait raw_input()) --> MyTurn [play]

    """
    # Initialise node
    rospy.init_node('smach')
    # Initialise Action Servers
    client = Client()

    # Create the top level SMACH state machine
    sm_top = smach.StateMachine(outcomes=['end'])

    # Open the container
    with sm_top:
        # Setup State
        smach.StateMachine.add('SETUP',
                               SETUP(client),
                               transitions={'initialised': 'PICKCOLOR'})
        # Pick Color State
        smach.StateMachine.add('PICKCOLOR',
                               PICKCOLOR(client),
                               transitions={
                                   'red': 'MYTURN',
                                   'black': 'WAIT'
                               })
        # Wait State
        smach.StateMachine.add('WAIT', WAIT(), transitions={'play': 'MYTURN'})
        # My Turn State
        smach.StateMachine.add('MYTURN',
                               MYTURN(client),
                               transitions={
                                   'move': 'MOVE',
                                   'exit': 'SHUTDOWN'
                               },
                               remapping={'moves': 'moves'})
        # Move State
        smach.StateMachine.add('MOVE',
                               MOVE(client),
                               transitions={
                                   'wait': 'WAIT',
                                   'exit': 'SHUTDOWN'
                               },
                               remapping={'moves': 'moves'})
        # Shutdown State
        smach.StateMachine.add('SHUTDOWN',
                               SHUTDOWN(),
                               transitions={'end': 'end'})

    # SMACH Viewer
    # Create and start the introspection server
    # sis = smach_ros.IntrospectionServer('checkers_smach', sm_top, '/CHECKERS')
    # sis.start()
    # Execute SMACH plan
    sm_top.execute()

    # rospy.spin()
    # sis.stop()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass