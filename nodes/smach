#!/usr/bin/env python
"""
REFERENCE: https://github.com/ros-planning/moveit_tutorials/blob/master/doc/move_group_python_interface/scripts/move_group_python_interface_tutorial.py

DESCRIPTION: The Pick Place Action Server


SUBSCRIBERS:

SERVICES:
"""

import rospy
import smach
import smach_ros
import actionlib
from checkers.msg import PickPlaceAction, PickPlaceGoal
import baxter_interface


class Client():
    def __init__(self):
        # Enable Baxter
        baxter_interface.robot_enable.RobotEnable()
        rospy.loginfo("Baxter Enabled!")
        # Initialise pick place client
        self.pp_client = actionlib.SimpleActionClient('pick_place_as',
                                                      PickPlaceAction)
        # Wait for server response
        self.pp_client.wait_for_server()
        rospy.loginfo("Server Initialised!")
        # Initialise goal msg
        self.pp_goal = PickPlaceGoal()

    def feedback_pp(self, msg):
        # do something here
        rospy.loginfo("Completed Moves: {}".format(msg))


class SETUP(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self, outcomes=['initialised'])
        # Initialise client
        self.client = client

    def setup_goal(self,
                   pick_goal=[0, 0],
                   place_goal=[0, 0],
                   home=False,
                   calibrate=False,
                   camera_view=False,
                   camera_home=False):
        """ DESCRIPTION

            Args:

            Returns:
        """
        self.client.pp_goal.home = home
        self.client.pp_goal.pick_goal = pick_goal
        self.client.pp_goal.place_goal = place_goal
        self.client.pp_goal.calibrate = calibrate
        self.client.pp_goal.camera_view = camera_view
        self.client.pp_goal.camera_home = camera_home
        self.client.pp_client.send_goal(self.client.pp_goal)
        self.client.pp_client.wait_for_result()
        if home is True:
            rospy.loginfo("Returned to Home Position")

        elif calibrate is True:
            rospy.loginfo("Calibrated")

        elif camera_view is True:
            rospy.loginfo("Camera at View Position")

        elif camera_home is True:
            rospy.loginfo("Camera at Home Position")

    def execute(self, userdata):
        rospy.loginfo('Initialising...')
        # Call Camera Calibration
        # Make sure pp arm at home
        self.setup_goal(home=True)
        # Put camera at view
        self.setup_goal(camera_view=True)
        # Input in case user wants to perform manual calibration
        rospy.loginfo("Hit enter when the camera arm is at the desired pose")
        raw_input()
        self.setup_goal(calibrate=True)
        # Return camera home
        self.setup_goal(camera_home=True)

        # Display on screen: please set up the board and
        # hit enter when ready
        rospy.loginfo('Please set up the board and hit enter when ready')
        raw_input()

        return 'initialised'


class PICKCOLOR(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self, outcomes=['red', 'black'])
        # Initialise client
        self.client = client

    def execute(self, userdata):
        rospy.loginfo('Pick a color')
        # Call AS to determine if baxter is red or black
        # userdata.client.pc_client.send goal
        # userdata.client.pc_client.wait_for_result()
        # result = userdata.client.pc_client.get_result()
        color = raw_input()
        if color == 'b':
            return 'black'
        else:
            return 'red'


class WAIT(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['play'])

    def execute(self, userdata):
        rospy.loginfo('Press Enter to end your turn')
        raw_input()

        return 'play'


class MYTURN(smach.State):
    # Pass Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self,
                             outcomes=['move', 'exit'],
                             output_keys=['board_state'])
        # Initialise client
        self.client = client

    def execute(self, userdata):
        rospy.loginfo('Reading board state')
        # Call AS to read board state and feed data to logic
        # userdata.client.boardstate_client.send goal
        # userdata.client.board_client.wait_for_result()
        # result = userdata.client.boardstate_client.get_result()
        # userdata.board_state = result
        rospy.loginfo("Let's see how well you played...")

        # Call logic function to determine win/lose
        end_game = False
        status = "win"
        if end_game is True:
            if status == "win":
                rospy.loginfo("Ha! I win!")
            elif status == "draw":
                rospy.loginfo("Everyone is a winner!")
            elif status == "lose":
                rospy.loginfo("You win :(")
            return 'exit'
        else:
            return 'move'


class MOVE(smach.State):
    # Place Client Object in State init
    def __init__(self, client):
        smach.State.__init__(self,
                             outcomes=['wait', 'exit'],
                             input_keys=['board_state'])
        # Initialise client
        self.client = client

    def pp_goal(self,
                pick_goal=[0, 0],
                place_goal=[0, 0],
                home=False,
                calibrate=False,
                camera_view=False,
                camera_home=False):
        """ DESCRIPTION

            Args:

            Returns:
        """
        self.client.pp_goal.pick_goal = pick_goal
        self.client.pp_goal.place_goal = place_goal
        self.client.pp_goal.home = home
        self.client.pp_goal.calibrate = calibrate
        self.client.pp_goal.camera_view = camera_view
        self.client.pp_goal.camera_home = camera_home

        if home is True or calibrate is True or camera_view is True or camera_home is True:
            self.client.pp_client.send_goal(self.client.pp_goal)
            self.client.pp_client.wait_for_result()
            if home is True:
                rospy.loginfo("Returned to Home Position")
            elif calibrate is True:
                rospy.loginfo("Calibrated")
            elif camera_view is True:
                rospy.loginfo("Camera at View Position")
            elif camera_home is True:
                rospy.loginfo("Camera at Home Position")

        else:
            self.client.pp_client.send_goal(
                self.client.pp_goal, feedback_cb=self.client.feedback_pp)
            self.client.pp_client.wait_for_result()
            cart = self.client.pp_client.get_result()
            rospy.loginfo("Cartesian path {}".format(cart))

    def execute(self, userdata):
        # Call Logic fcn to determine next move
        # userdata.client.move_client.send goal board_state
        # userdata.client.move_client.wait_for_result()
        # result = userdata.client.move_client.get_result()

        # Call AS to put camera at home position
        self.pp_goal(camera_home=True)

        # Call AS to perform pick-place per move
        # FOR EACH BAXTER MOVE
        pick_goal = [0, 0]  # [0.5 * 0.0559, -0.5 * 0.0559]
        place_goal = [0, 0]
        home = False
        self.pp_goal(pick_goal, place_goal, home)

        # Call AS to perform pick-place per discard
        # FOR EACH BAXTER DISCARD
        pick_goal = [0, 0]
        place_goal = [0, 0]
        home = False
        self.pp_goal(pick_goal, place_goal, home)

        # Call AS to go home to clear board for camera
        self.pp_goal(home=True)

        # Call AS to put camera at view position
        self.pp_goal(camera_view=True)

        # Call logic function to determine win/lose
        end_game = False
        status = "win"
        if end_game is True:
            if status == "win":
                rospy.loginfo("Ha! I win!")
            elif status == "draw":
                rospy.loginfo("Everyone is a winner!")
            elif status == "lose":
                rospy.loginfo("You win :(")
            return 'exit'
        else:
            return 'wait'


class SHUTDOWN(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['end'])

    def execute(self, userdata):
        rospy.loginfo('Disabling Baxter...')
        # Disable Baxter
        baxter_interface.robot_enable.RobotDisable()
        rospy.loginfo("Baxter Disabled!")

        return 'end'


def main():
    """ The Main Function

        Call Client to initialise action servers

        State Machine Hierarchy:
        (AS means Action Server, outcomes are in square brackets)

        STATE_MACHINE

        - Setup (AS: Calibrate Camera - run until successful calibration
          --> AS: Calibrate EE-Board transform -->
          DISPLAY: Ask human to put pieces on board (raw_input) [initialised])

        - AS: Baxter_Red_or_Black (two outcomes)
            -- Black: [wait] --> Wait raw_input()
            -- Red: [play] --> MyTurn
        - Wait raw_input() [play] --> MyTurn
        - MyTurn (AS: Read Board [check] --> Logic_win_lose_draw (two outcomes)
            -- [wld] Win/Lose/Draw [exit] --> ShutDown [end]
            -- [move] Next_Move [pickplace] --> AS: PickPlace [check]
                --> Logic_win_lose_draw (two outcomes)
                    -- [wld] Win/Lose/Draw [exit] --> ShutDown ([end]
                    -- [wait] Wait raw_input()) --> MyTurn [play]

    """
    # Initialise node
    rospy.init_node('smach')
    # Initialise Action Servers
    client = Client()

    # Create the top level SMACH state machine
    sm_top = smach.StateMachine(outcomes=['end'])

    # Open the container
    with sm_top:
        # Setup State
        smach.StateMachine.add('SETUP',
                               SETUP(client),
                               transitions={'initialised': 'PICKCOLOR'})
        # Pick Color State
        smach.StateMachine.add('PICKCOLOR',
                               PICKCOLOR(client),
                               transitions={
                                   'red': 'MYTURN',
                                   'black': 'WAIT'
                               })
        # Wait State
        smach.StateMachine.add('WAIT', WAIT(), transitions={'play': 'MYTURN'})
        # My Turn State
        smach.StateMachine.add('MYTURN',
                               MYTURN(client),
                               transitions={
                                   'move': 'MOVE',
                                   'exit': 'SHUTDOWN'
                               },
                               remapping={'board_state': 'board_state'})
        # Move State
        smach.StateMachine.add('MOVE',
                               MOVE(client),
                               transitions={
                                   'wait': 'WAIT',
                                   'exit': 'SHUTDOWN'
                               },
                               remapping={'board_state': 'board_state'})
        # Shutdown State
        smach.StateMachine.add('SHUTDOWN',
                               SHUTDOWN(),
                               transitions={'end': 'end'})

    # SMACH Viewer
    # Create and start the introspection server
    # sis = smach_ros.IntrospectionServer('checkers_smach', sm_top, '/CHECKERS')
    # sis.start()
    # Execute SMACH plan
    sm_top.execute()

    # rospy.spin()
    # sis.stop()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass