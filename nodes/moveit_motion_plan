#!/usr/bin/env python
""" 
REFERENCE: https://github.com/ros-planning/moveit_tutorials/blob/master/doc/move_group_python_interface/scripts/move_group_python_interface_tutorial.py

DESCRIPTION:


SUBSCRIBERS:

SERVICES:
"""

import sys
import copy
import rospy
import numpy as np
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp, PlaceLocation  # For pickplace
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint  # for pickplace
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
import tf.transformations as tr


class PickPlace(object):
    """
    """
    def __init__(self):
        rospy.loginfo("Initializing Baxter")
        super(PickPlace, self).__init__()
        # Initialize moveit_commander with kin model
        # and current joint states
        # This remap is important because otherwise it is impossible
        # to read the robot's End Effector Pose. The launchfile
        # Also must have this remap
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)
        # roscpp_initialize(sys.argv)
        # joint_state_topic = ['joint_states:=/joint_states_desired']
        # moveit_commander.roscpp_initialize(joint_state_topic)
        # moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        # Remote interface for getting, setting and updating
        # robot's belief of surroundings
        self.scene = moveit_commander.PlanningSceneInterface()
        # Interface used to execute motions
        self.move_group = moveit_commander.MoveGroupCommander("right_arm")

        # Display Trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)

        # Getting Basic Information
        # Get robot reference frame name
        self.planning_frame = self.move_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.move_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.group_names)

        # DEBUG: Print Robot State
        self.robot_state = self.robot.get_current_state()
        rospy.loginfo("========== CURRENT STATE: %s" % self.robot_state)

        # Planning and Execurtion parameters
        self.move_group.set_goal_position_tolerance(0.01)
        self.move_group.set_goal_orientation_tolerance(0.01)
        self.move_group.set_planning_time(5.0)
        self.move_group.allow_replanning(True)
        self.move_group.set_max_velocity_scaling_factor(0.6)
        self.move_group.set_max_acceleration_scaling_factor(0.6)

        # State Gripper (L/R)
        self.right_gripper = Gripper('right', CHECK_VERSION)
        # Reboot Gripper
        self.right_gripper.reboot()
        # Calibrate Gripper
        self.right_gripper.calibrate()
        # Open Gripper
        self.right_gripper.open()

        # Standoff is the amount by which we approach
        # and retreat pre and post grasp
        self.standoff = 0.1

        # z is the z position of the objects we want to grasp
        # set to the table z origin plus half the table height
        self.z = -0.311 + 0.05

        # Initialise attribute for desired EE Pose
        self.pose_goal = Pose()

        # Grasp Message
        self.pick = Grasp()

        # PlaceLocation Message
        self.place = PlaceLocation()

        # Chekcers piece
        # self.puck = CollisionObject()

    def add_box(self, timeout=4):
        """ Adds a box to the Planning Scene
            so that Baxter knows to avoid it with
            all its links as its IK solver finds a
            solution for a given motion plan
        """
        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.311
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def attach_object(self, timeout=4):
        """ Attach a box (a checkers puck in this case)
            to the EE so that the Planning Scene doesn't
            report this connection as a collision. We get
            all the link names from the grasping group to tell
            the planning scene to ignore any collisions between
            the picked up box and these links.
        """
        box_name = self.box_name
        grasping_group = 'right_hand'
        touch_links = self.robot.get_link_names(group=grasping_group)
        self.scene.attach_box(self.eef_link, box_name, touch_links=touch_links)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=True, box_is_known=False, timeout=timeout)

    def detach_object(self, timeout=4):
        """ Here we detach the object from the EE
            since we have released it, and its prior
            collision properties are restored.
        """
        box_name = self.box_name
        # Detaching Objects from the Robot
        # We can also detach and remove the object from the planning scene:
        self.scene.remove_attached_object(self.eef_link, name=box_name)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_known=True, box_is_attached=False, timeout=timeout)

    def remove_object(self, timeout=4):
        """ Here we remove the object from the world.
            NOTE that the object must be detached before
            it can be removed.
        """
        box_name = self.box_name
        # Remove the box from the world.
        self.scene.remove_world_object(box_name)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=False, box_is_known=False, timeout=timeout)

    def wait_for_state_update(self,
                              box_is_known=False,
                              box_is_attached=False,
                              timeout=4):
        """ If the Python node dies before publishing a collision object update
            message, the message could get lost and the box will not appear.
            To ensure that the updates are made, we wait until we see the
            changes reflected in the ``get_attached_objects()`` and
            ``get_known_object_names()`` lists.
            For the purpose of this tutorial, we call this function after
            adding, removing, attaching or detaching an object in the planning
            scene. We then wait until the updates have been made or ``timeout``
            seconds have passed
        """

        box_name = self.box_name
        scene = self.scene

        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in scene.get_known_object_names()

        # Test if we are in the expected state
        if (box_is_attached == is_attached) and (box_is_known == is_known):
            return True

        # Sleep so that we give other threads time on the processor
        rospy.sleep(0.1)
        seconds = rospy.get_time()

        # If we exiterd the while loop without returning then we timed out
        return False

    def go_to_pose_goal(self, goal=[0.5, 0.0]):
        """ This function is called to bring the EE to its
            home position, or to actuate it in case the cartesian
            planner fails to return a solution that traces the
            desired trajectory to a minimum threshold

            Args: goal, a 2-element list with an x and y
            component which comprise the goal coordinates in
            the x-y plane.

            Returns: Moves the robobt arm to (goal[0], goal[1], 0)
        """
        move_group = self.move_group
        # Planning to a Pose Goal
        # We can plan a motion for this group to a desired pose for the
        # end-effector:
        pose_goal = Pose()
        # Quaternion from Euler
        # quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        # rospy.loginfo("QUATERNION FOUND {}".format(quaternion))
        # Make the EE point down
        pose_goal.orientation.x = 1
        pose_goal.orientation.y = 0
        pose_goal.orientation.z = 0
        pose_goal.orientation.w = 0
        pose_goal.position.x = goal[0]
        pose_goal.position.y = goal[1]
        pose_goal.position.z = 0.0

        # Set the pose target
        move_group.set_pose_target(pose_goal)
        # Now, we call the planner to compute the plan and execute it.
        move_group.go(wait=True)
        # Calling `stop()` ensures that there is no residual movement
        move_group.stop()
        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        move_group.clear_pose_targets()
        # For testing:
        # current_pose = self.move_group.get_current_pose().pose

    def pick_routine(self, goal):
        """ UNUSED. CARTESIAN PLANNER IS BETTER
        """
        # PRE GRASP GOAL
        pre_grasp_goal = Pose()
        # Always point EE down
        pre_grasp_goal.orientation.x = 1
        pre_grasp_goal.position.x = goal[0]
        pre_grasp_goal.position.y = goal[1]
        # Set approach position w standoff
        pre_grasp_goal.position.z = self.z + self.standoff

        # Now move
        self.move_group.set_pose_target(pre_grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

        # GRASP GOAL
        grasp_goal = Pose()
        # Always point EE down
        grasp_goal.orientation.x = 1
        grasp_goal.position.x = goal[0]
        grasp_goal.position.y = goal[1]
        # Set grasp position w/o standoff
        grasp_goal.position.z = self.z

        # Now move
        self.move_group.set_pose_target(grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        # Close Gripper to grasp
        self.right_gripper.close()

        rospy.sleep(0.5)

        # RETREAT GOAL (same as pre-grasp)
        # Now move
        self.move_group.set_pose_target(pre_grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

    def place_routine(self, goal):
        """ UNUSED. CARTESIAN PLANNER IS BETTER
        """
        # PRE PLACE GOAL
        pre_place_goal = Pose()
        # Always point EE down
        pre_place_goal.orientation.x = 1
        pre_place_goal.position.x = goal[0]
        pre_place_goal.position.y = goal[1]
        # Set approach position w standoff
        pre_place_goal.position.z = self.z + self.standoff

        # Now move
        self.move_group.set_pose_target(pre_place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

        # PLACE GOAL
        place_goal = Pose()
        # Always point EE down
        place_goal.orientation.x = 1
        place_goal.position.x = goal[0]
        place_goal.position.y = goal[1]
        # Set grasp position w/o standoff
        place_goal.position.z = self.z

        # Now move
        self.move_group.set_pose_target(place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        # Open Gripper to release
        self.right_gripper.open()

        rospy.sleep(0.5)

        # RETREAT GOAL (same as pre-place)
        # Now move
        self.move_group.set_pose_target(pre_place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

    def pick_cartesian(self, goal):
        """ Receives a pick goal and performs 4 actions:

            1 - Moves to a pre-grasp position (approach) in the
            x-y position of the supplied goal, but offset in the z
            axis. This is done using the plan_cartesian_path method
            which is supplied a set of waypoints linearly interpolating
            between the EE's current pose and its desired pose, with
            the final waypoint having the EE pointing down.

            2- Moves to the grasp position by changing the EE z position
            using the plan_cartesian_path method.

            3- Closes the grippers to grasp the object

            4- Moves to a post-grasp (retreat) position in the x-y position
            of the supplied goal but offset in the z axis. This is done using
            the plan_cartesian_path method.

            Note that if we force the trajectory to have the EE point down at
            each waypoint, its odds of solving are greatly reduced, so we only
            place this constraint on the last waypoint.

            Args: goal (list of two elements, x and y goal position)

            Returns: Performs approach, grasp, and retreat actions
        """
        # APPROACH GOAL
        rospy.loginfo("================== Approach ==============")
        # Pass the goal and the approach z coordinate
        self.create_path(goal, self.z + self.standoff)

        # GRASP GOAL
        rospy.loginfo("================== Grasp ==============")
        # Pass the goal and the grasp z coordinate
        self.create_path(goal, self.z)

        # Close Gripper to grasp
        self.right_gripper.close()
        rospy.sleep(0.5)

        # RETREAT GOAL (same as approach)
        rospy.loginfo("================== Retreat ==============")
        # Pass the goal and the retreat z coordinate
        self.create_path(goal, self.z + self.standoff)

    def place_cartesian(self, goal):
        """ Receives a place goal and performs 4 actions:

            1 - Moves to a pre-place position (approach) in the
            x-y position of the supplied goal, but offset in the z
            axis. This is done using the plan_cartesian_path method
            which is supplied a set of waypoints linearly interpolating
            between the EE's current pose and its desired pose, with
            the final waypoint having the EE pointing down.

            2- Moves to the place position by changing the EE z position
            using the plan_cartesian_path method.

            3- Opens the grippers to place/release the object

            4- Moves to a post-place (retreat) position in the x-y position
            of the supplied goal but offset in the z axis. This is done using
            the plan_cartesian_path method.

            Note that if we force the trajectory to have the EE point down at
            each waypoint, its odds of solving are greatly reduced, so we only
            place this constraint on the last waypoint.

            Args: goal (list of two elements, x and y goal position)

            Returns: Performs approach, release, and retreat actions
        """
        # APPROACH GOAL
        rospy.loginfo("================== Approach ==============")
        # Pass the goal and the approach z coordinate
        self.create_path(goal, self.z + self.standoff)

        # RELEASE GOAL
        rospy.loginfo("================== Release ==============")
        # Pass the goal and the release z coordinate
        self.create_path(goal, self.z)

        # Close Gripper to grasp
        self.right_gripper.open()
        rospy.sleep(0.5)

        # RETREAT GOAL (same as approach)
        rospy.loginfo("================== Retreat ==============")
        # Pass the goal and the release z coordinate
        self.create_path(goal, self.z + self.standoff, iter=10)

    def create_path(self, goal, z, iter=20):
        """ Creates list of waypoint poses that make up cartesian
            path.

            Args: goal (two-element list of an x and y position)

            z (z coordinate of the goal position, which may or may
            not contain the standoff offset)

            iter (number of waypoints in the listt)

            Returns: waypoints

            Passes: goal
        """
        # Get Current EE Pose
        ee_pose = self.move_group.get_current_pose().pose
        # Initialise list of waypoitns
        waypoints = []
        # Linearly interpolate between current and goal poses
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        # z may or may not contain the standoff offset
        ziter = np.linspace(ee_pose.position.z, z, iter)
        # Set each trajectory element
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down for the final waypoint
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

    def plan_cartesian_path(self, waypoints, goal):
        """ Calls compute_cartesian_path method from the
            move_group object to create a constrained path
            for the EE to follow. This is done in multiple attempts
            untill a satisfactory path is found and executed. Paths
            are assessed by their completion of the desired trajectory.

            If a path is not found to a certain standard, the go_to_pose_goal
            method is instread called, which sends the EE to the goal, albeit
            with an unconstrained path. This is a worst-case scenario.

            Args: waypoints (list of poses for the EE to mmove through
            during the cartesian path)

            goal (two-element list containing an x and y position for the EE)

            Returns: creates and executes path
        """
        # Scale = -1 for python according to tutorial
        # You can plan a Cartesian path by specifying a list of waypoints
        # for the end-effector to go through:
        self.move_group.set_start_state_to_current_state()
        fraction = 0.0
        max_attempts = 50
        attempts = 0

        # Plan the Cartesian path connecting the waypoints
        # We want the Cartesian path to be interpolated at a resolution of 1 cm
        # which is why we will specify 0.01 as the eef_step in Cartesian
        # translation.  Disable jump thresh by setting it to 0.0
        # waypoints to follow, eef_step, jump_threshold
        while fraction <= 0.8 and attempts < max_attempts:
            plan, fraction = self.move_group.compute_cartesian_path(waypoints, 0.01, 0.0)
            # Increment the number of attempts
            attempts += 1
        # If we have a complete plan, execute the trajectory
        if fraction >= 0.8:
            rospy.loginfo("Path computed successfully. Moving the arm.")
            self.move_group.execute(plan, wait=True)

        else:
            rospy.logerr("Could not find valid cartesian path")
            # Go back to start
            self.go_to_pose_goal(goal)

    def pick_cpp(self):
        """ DOES NOT WORK. ATTEMPTED TO TRANSLATE CPP CODE TO PYTHON
            FROM MOVEIT PICK AND PLACE TUTORIAL
            DESCRIPTION

            Args:

            Returns:
        """
        # PICK POSE
        self.pick.grasp_pose.header.frame_id = "base"
        # Quaternion from Euler
        # quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        self.pick.grasp_pose.pose.orientation.x = 1
        self.pick.grasp_pose.pose.orientation.y = 0
        self.pick.grasp_pose.pose.orientation.z = 0
        self.pick.grasp_pose.pose.orientation.w = 0
        self.pick.grasp_pose.pose.position.x = 0.5
        self.pick.grasp_pose.pose.position.y = 0.0
        self.pick.grasp_pose.pose.position.z = -0.3075 + 0.1

        # APPROACH
        # Defined with respect to frame_id
        self.pick.pre_grasp_approach.direction.header.frame_id = "base"
        # Direction in negative z-axis for pre-grasp direction (up)
        self.pick.pre_grasp_approach.direction.vector.z = -1.0
        self.pick.pre_grasp_approach.min_distance = 0.095
        self.pick.pre_grasp_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.pick.post_grasp_retreat.direction.header.frame_id = "base"
        # Direction is set as positive z axis
        self.pick.post_grasp_retreat.direction.vector.z = 1.0
        self.pick.post_grasp_retreat.min_distance = 0.1
        self.pick.post_grasp_retreat.desired_distance = 0.25

        # PRE-GRASP POSTURE: OPEN GRIPPER
        pre_grasp_posture = JointTrajectory()
        pre_grasp_posture.header.frame_id = "base"
        pre_grasp_posture.header.stamp = rospy.Time.now()
        pre_grasp_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(1.0)
        pos.positions.append(1.0)
        pre_grasp_posture.points.append(pos)
        self.pick.pre_grasp_posture = pre_grasp_posture

        # GRASP POSTURE: CLOSE GRIPPER
        grasp_posture = JointTrajectory()
        grasp_posture.header.frame_id = "base"
        grasp_posture.header.stamp = rospy.Time.now()
        grasp_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(0.0)
        pos.positions.append(0.0)
        grasp_posture.points.append(pos)
        self.pick.grasp_posture = pre_grasp_posture

        # Set Support Surface
        # self.move_group.setSupportSurfaceName("table")
        # Perform pick method using grasp vars
        self.move_group.pick("puck", self.pick)

    def place_cpp(self):
        """ DOES NOT WORK. ATTEMPTED TO TRANSLATE CPP CODE TO PYTHON
            FROM MOVEIT PICK AND PLACE TUTORIAL
            DESCRIPTION

            Args:

            Returns:
        """
        # PLACE POSE
        self.place.place_pose.header.frame_id = "base"
        # Quaternion from Euler
        # quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        self.place.place_pose.pose.orientation.x = 1
        self.place.place_pose.pose.orientation.y = 0
        self.place.place_pose.pose.orientation.z = 0
        self.place.place_pose.pose.orientation.w = 0
        self.place.place_pose.pose.position.x = 0.5
        self.place.place_pose.pose.position.y = 0.0
        self.place.place_pose.pose.position.z = -0.3075 + 0.1

        # APPROACH
        # Defined with respect to frame_id
        self.place.pre_place_approach.direction.header.frame_id = "base"
        # Direction is set as negative z axis
        self.place.pre_place_approach.direction.vector.z = -1.0
        self.place.pre_place_approach.min_distance = 0.095
        self.place.pre_place_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.place.post_place_retreat.direction.header.frame_id = "base"
        # Direction is set as negative y axis
        self.place.post_place_retreat.direction.vector.y = -1.0
        self.place.post_place_retreat.min_distance = 0.1
        self.place.post_place_retreat.desired_distance = 0.25

        # POST PLACE POSTURE: OPEN GRIPPER
        post_place_posture = JointTrajectory()
        post_place_posture.header.frame_id = "base"
        post_place_posture.header.stamp = rospy.Time.now()
        post_place_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(0.0)
        pos.positions.append(0.0)
        post_place_posture.points.append(pos)
        self.place.post_place_posture = post_place_posture

        # Set Support Surface
        # self.move_group.setSupportSurfaceName("table")
        # Perform place method using grasp vars
        self.move_group.place("puck", self.place)

    def pp_object(self):
        """ Create a small, puck-sized object and adds it
            to the scene
        """
        # Define the object that we will be manipulating
        self.puck_pose = PoseStamped()
        self.puck_name = "puck"

        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.puck_pose.header.frame_id = "base"
        self.puck_pose.pose.position.x = 0.5
        self.puck_pose.pose.position.z = -0.3075 + 0.05
        self.puck_pose.pose.orientation.w = 1.0
        # TODO: Change to Cylinder
        self.scene.add_box(self.puck_name,
                           self.puck_pose,
                           size=(25e-3, 25e-3, 10e-3))

    def open_gripper(self):
        """ DOES NOT WORK. ATTEMPTED TO TRANSLATE CPP CODE INTO PYTHON
            FROM MOVEIT PICK AND PLACE TUTORIAL. JOINT NAMES NOT
            RECOGNIZED
        """
        pos_l = JointTrajectory()
        pos_r = JointTrajectory()

        # Names
        pos_l.posture.joint_names = "r_gripper_l_finger"
        pos_r.posture.joint_names = "r_gripper_r_finger"

        # Open
        pos_l.posture.points.positions = 1
        pos_l.posture.points.time_from_start = rospy.Duration(0.5)
        pos_r.posture.points.positions = 1
        pos_r.posture.points.time_from_start = rospy.Duration(0.5)


def main():
    rospy.init_node("moveit_motion_plan", anonymous=True)

    try:

        print ""
        print "----------------------------------------------------------"
        print "MoveIt!"
        print "----------------------------------------------------------"
        print "Press Ctrl-D to exit at any time"
        print ""
        tutorial = PickPlace()

        print "============ Add a box and checkers piece to the planning scene ..."
        tutorial.add_box()
        # tutorial.pp_object()

        # print "============ Press `Enter` to execute a movement using a joint state goal ..."
        # raw_input()
        # tutorial.go_to_joint_state()

        print "============ Press `Enter` to execute a movement using a pose goal ..."
        raw_input()
        tutorial.go_to_pose_goal()

        print "============ Press `Enter` to Pick ..."
        raw_input()
        tutorial.pick_cartesian([0.59, -0.06])

        print "============ Press `Enter` to Place ..."
        raw_input()
        tutorial.place_cartesian([0.49, -0.06])

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()