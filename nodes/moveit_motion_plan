#!/usr/bin/env python
""" REFERENCE: https://github.com/ros-planning/moveit_tutorials/blob/master/doc/move_group_python_interface/scripts/move_group_python_interface_tutorial.py
"""

import sys
import copy
import rospy
import numpy as np
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp, CollisionObject  # For pickplace
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
from baxter_interface import Gripper, CHECK_VERSION
import tf.transformations as tr


class PickPlace(object):
    def __init__(self):
        # Initialize moveit_commander with kin model
        # and current joint states
        rospy.loginfo("Initializing Baxter")
        super(PickPlace, self).__init__()
        # joint_state_topic = ['joint_states:=/joint_states_desired']
        # moveit_commander.roscpp_initialize(joint_state_topic)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        # Remote interface for getting, setting and updating
        # robot's belief of surroundings
        self.scene = moveit_commander.PlanningSceneInterface()
        # Interface used to execute motions
        self.move_group = moveit_commander.MoveGroupCommander("right_arm")

        # Display Trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)

        # Getting Basic Information

        # Get robot reference frame name
        self.planning_frame = self.move_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.move_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.group_names)

        # DEBUG: Print Robot State
        self.robot_state = self.robot.get_current_state()
        rospy.loginfo("========== CURRENT STATE: %s" % self.robot_state)

        # Planning and Execurtion parameters
        self.move_group.set_goal_position_tolerance(0.01)
        self.move_group.set_goal_orientation_tolerance(0.01)
        self.move_group.set_planning_time(5.0)
        self.move_group.allow_replanning(False)
        self.move_group.set_max_velocity_scaling_factor(0.6)
        self.move_group.set_max_acceleration_scaling_factor(0.6)

        # State Gripper (L/R)
        self.right_gripper = Gripper('right', CHECK_VERSION)
        # Reboot Gripper
        self.right_gripper.reboot()
        # Calibrate Gripper
        self.right_gripper.calibrate()
        # Open Gripper
        self.right_gripper.open()
        # tutorial.right_gripper.close()

        # Initialise attribute for desired EE Pose
        self.pose_goal = Pose()

        # Grasp Message
        self.grasp = Grasp()

        # Chekcers piece
        self.puck = CollisionObject()

    def add_box(self, timeout=4):
        """
        """
        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.3075
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def attach_box(self, timeout=4):
        box_name = self.box_name
        robot = self.robot
        scene = self.scene
        eef_link = self.eef_link
        group_names = self.group_names
        # Next, we will attach the box to the Panda wrist. Manipulating objects requires the
        # robot be able to touch them without the planning scene reporting the contact as a
        # collision. By adding link names to the ``touch_links`` array, we are telling the
        # planning scene to ignore collisions between those links and the box. For the Panda
        # robot, we set ``grasping_group = 'hand'``. If you are using a different robot,
        # you should change this value to the name of your end effector group name.
        grasping_group = 'right_hand'
        touch_links = robot.get_link_names(group=grasping_group)
        scene.attach_box(eef_link, box_name, touch_links=touch_links)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=True, box_is_known=False, timeout=timeout)

    def detach_box(self, timeout=4):
        box_name = self.box_name
        scene = self.scene
        eef_link = self.eef_link
        # Detaching Objects from the Robot
        # We can also detach and remove the object from the planning scene:
        scene.remove_attached_object(eef_link, name=box_name)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_known=True, box_is_attached=False, timeout=timeout)

    def remove_box(self, timeout=4):
        box_name = self.box_name
        scene = self.scene
        # We can remove the box from the world.
        scene.remove_world_object(box_name)
        # **Note:** The object must be detached before we can remove it from the world
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=False, box_is_known=False, timeout=timeout)

    def wait_for_state_update(self, box_is_known=False, box_is_attached=False, timeout=4):
        """ If the Python node dies before publishing a collision object update
            message, the message could get lost and the box will not appear.
            To ensure that the updates are made, we wait until we see the
            changes reflected in the ``get_attached_objects()`` and
            ``get_known_object_names()`` lists.
            For the purpose of this tutorial, we call this function after
            adding, removing, attaching or detaching an object in the planning
            scene. We then wait until the updates have been made or ``timeout``
            seconds have passed
        """

        box_name = self.box_name
        scene = self.scene

        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in scene.get_known_object_names()

        # Test if we are in the expected state
        if (box_is_attached == is_attached) and (box_is_known == is_known):
            return True

        # Sleep so that we give other threads time on the processor
        rospy.sleep(0.1)
        seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False

    def go_to_joint_state(self):
        move_group = self.move_group
        # Planning to a Joint Goal
        # We can get the joint values from the group and adjust some of the values:
        joint_goal = move_group.get_current_joint_values()
        joint_goal[0] = 0
        joint_goal[1] = -pi/4
        joint_goal[2] = 0
        joint_goal[3] = -pi/2
        joint_goal[4] = 0
        joint_goal[5] = pi/3
        joint_goal[6] = 0

        # The go command can be called with joint values, poses, or without any
        # parameters if you have already set the pose or joint target for the group
        move_group.go(joint_goal, wait=True)

        # Calling ``stop()`` ensures that there is no residual movement
        move_group.stop()

    def compute_cartesian(self):
        testingdata = np.array([0.6, -0.320147457674, -0.209, np.pi])
        data = testingdata

        rospy.loginfo("++++++++++Received desired position+++++++++")
        # extract x,y,z coordinate from subscriber data
        self.x_coord = data[0]
        self.y_coord = data[1]
        self.z_coord = data[2]
        theta = data[3]
        # put coordinate data back to arrays
        pout = np.array([self.x_coord, self.y_coord, self.z_coord])
        block_orientation = tr.quaternion_from_euler(theta, 0, 0, 'sxyz')
        # convert orentation and position to Quaternion
        quat = Quaternion(*block_orientation)

        self.quat_position = Point(*pout)
        self.quat_orientation = copy.deepcopy(quat)
        self.cartesian_reader = True

    def go_to_pose_goal(self):
        move_group = self.move_group
        # Planning to a Pose Goal
        # We can plan a motion for this group to a desired pose for the
        # end-effector:
        pose_goal = Pose()
        # Quaternion from Euler
        quaternion = tr.quaternion_from_euler(0, -np.pi / 2, 0)
        pose_goal.orientation.x = quaternion[0]
        pose_goal.orientation.y = quaternion[1]
        pose_goal.orientation.z = quaternion[2]
        pose_goal.orientation.w = quaternion[3]
        pose_goal.position.x = 0.4
        pose_goal.position.y = 0.4
        pose_goal.position.z = -0.15

        move_group.set_pose_target(pose_goal)

        # Now, we call the planner to compute the plan and execute it.
        plan = move_group.go(wait=True)
        # Calling `stop()` ensures that there is no residual movement
        move_group.stop()
        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        move_group.clear_pose_targets()
        # For testing:
        # current_pose = self.move_group.get_current_pose().pose

    def plan_cartesian_path(self, scale=1):
        move_group = self.move_group
        # Cartesian Paths
        # You can plan a Cartesian path directly by specifying a list of waypoints
        # for the end-effector to go through. If executing  interactively in a
        # Python shell, set scale = 1.0.
        waypoints = []

        wpose = move_group.get_current_pose().pose
        wpose.position.z -= scale * 0.1  # First move up (z)
        wpose.position.y += scale * 0.2  # and sideways (y)
        waypoints.append(copy.deepcopy(wpose))

        wpose.position.x += scale * 0.1  # Second move forward/backwards in (x)
        waypoints.append(copy.deepcopy(wpose))

        wpose.position.y -= scale * 0.1  # Third move sideways (y)
        waypoints.append(copy.deepcopy(wpose))

        # We want the Cartesian path to be interpolated at a resolution of 1 cm
        # which is why we will specify 0.01 as the eef_step in Cartesian
        # translation.  We will disable the jump threshold by setting it to 0.0,
        # ignoring the check for infeasible jumps in joint space, which is sufficient
        # for this tutorial
        (plan, fraction) = move_group.compute_cartesian_path(
                                           waypoints,   # waypoints to follow
                                           0.01,        # eef_step
                                           0.0)         # jump_threshold

        # Note: We are just planning, not asking move_group to actually move the robot yet:
        return plan, fraction

        ## END_SUB_TUTORIAL

    def display_trajectory(self, plan):
        robot = self.robot
        display_trajectory_publisher = self.display_trajectory_publisher

        # Displaying a Trajectory
        # You can ask RViz to visualize a plan (aka trajectory) for you. But the
        # group.plan() method does this automatically so this is not that useful
        # here (it just displays the same trajectory again):
        # A `DisplayTrajectory`_ msg has two primary fields, trajectory_start and trajectory.
        # We populate the trajectory_start with our current robot state to copy over
        # any AttachedCollisionObjects and add our plan to the trajectory.
        display_trajectory = moveit_msgs.msg.DisplayTrajectory()
        display_trajectory.trajectory_start = robot.get_current_state()
        display_trajectory.trajectory.append(plan)
        # Publish
        display_trajectory_publisher.publish(display_trajectory);

    def execute_plan(self, plan):
        move_group = self.move_group

        # Executing a Plan
        # Use execute if you would like the robot to follow
        # the plan that has already been computed:
        move_group.execute(plan, wait=True)

        # **Note:** The robot's current joint state must be within some tolerance of the
        # first waypoint in the `RobotTrajectory`_ or ``execute()`` will fail

    def pick(self):
        """ DESCRIPTION

            Args:

            Returns:
        """
        # PICK POSE
        self.grasp.grasp_pose.header.frame_id = "base"
        # Quaternion from Euler
        quaternion = tr.quaternion_from_euler(0, -np.pi / 2, 0)
        self.grasp.grasp_pose.pose.orientation.x = quaternion[0]
        self.grasp.grasp_pose.pose.orientation.y = quaternion[1]
        self.grasp.grasp_pose.pose.orientation.z = quaternion[2]
        self.grasp.grasp_pose.pose.orientation.w = quaternion[3]
        self.grasp.grasp_pose.pose.position.x = 0.4
        self.grasp.grasp_pose.pose.position.y = 0.4
        self.grasp.grasp_pose.pose.position.z = -0.15

        # APPROACH
        # Defined with respect to frame_id
        self.grasp.pre_grasp_approach.direction.header.frame_id = "base"
        # Direction in negative z-axis for pre-grasp direction (up)
        self.grasp.pre_grasp_approach.direction.vector.z = -1.0
        self.grasp.pre_grasp_approach.min_distance = 0.095
        self.grasp.pre_grasp_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.grasp.post_grasp_retreat.direction.header.frame_id = "base"
        # Direction is set as positive z axis
        self.grasp.post_grasp_retreat.direction.vector.z = 1.0
        self.grasp.post_grasp_retreat.min_distance = 0.1
        self.grasp.post_grasp_retreat.desired_distance = 0.25

        # PRE-GRASP POSTURE

        # GRASP POSTURE

        # Set Support Surface
        self.move_group.setSupportSurfaceName("table")
        # Perform pick method using grasp vars
        self.move_group.pick("puck", self.grasp)

    def place(self):
        """ DESCRIPTION

            Args:

            Returns:
        """
        # PLACE POSE
        self.grasp.place_pose.header.frame_id = "base"
        # Quaternion from Euler
        quaternion = tr.quaternion_from_euler(0, -np.pi / 2, 0)
        self.grasp.place_pose.pose.orientation.x = quaternion[0]
        self.grasp.place_pose.pose.orientation.y = quaternion[1]
        self.grasp.place_pose.pose.orientation.z = quaternion[2]
        self.grasp.place_pose.pose.orientation.w = quaternion[3]
        self.grasp.place_pose.pose.position.x = 0.4
        self.grasp.place_pose.pose.position.y = 0.4
        self.grasp.place_pose.pose.position.z = -0.15

        # APPROACH
        # Defined with respect to frame_id
        self.grasp.pre_place_approach.direction.header.frame_id = "base"
        # Direction is set as negative z axis
        self.grasp.pre_place_approach.direction.vector.z = -1.0
        self.grasp.pre_place_approach.min_distance = 0.095
        self.grasp.pre_place_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.grasp.post_place_retreat.direction.header.frame_id = "base"
        # Direction is set as negative y axis
        self.grasp.post_place_retreat.direction.vector.y = -1.0
        self.grasp.post_place_retreat.min_distance = 0.1
        self.grasp.post_place_retreat.desired_distance = 0.25

        # Set Support Surface
        self.move_group.setSupportSurfaceName("table")
        # Perform place method using grasp vars
        self.move_group.place("puck", self.grasp)

    def pp_object(self):
        """
        """
        # Define the object that we will be manipulating
        self.puck_pose = PoseStamped()
        self.puck_name = "puck"

        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.puck_pose.header.frame_id = "base"
        self.puck_pose.pose.position.x = 0.5
        self.puck_pose.pose.position.z = -0.3075 + 0.05
        self.puck_pose.pose.orientation.w = 1.0
        # TODO: Change to Cylinder
        self.scene.add_box(self.puck_name, self.puck_pose, size=(25e-3, 25e-3, 10e-3))

def main():
    rospy.init_node("moveit_motion_plan", anonymous=True)

    #listen to the topic which is publishing desired cartian coordinate

    # rospy.Subscriber("square-location",String,self.compute_cartesian)

    try:

        print ""
        print "----------------------------------------------------------"
        print "Welcome to the MoveIt MoveGroup Python Interface Tutorial"
        print "----------------------------------------------------------"
        print "Press Ctrl-D to exit at any time"
        print ""
        tutorial = PickPlace()

        print "============ Add a box and checkers piece to the planning scene ..."
        tutorial.add_box()
        tutorial.pp_object()

        # print "============ Press `Enter` to execute a movement using a joint state goal ..."
        # raw_input()
        # tutorial.go_to_joint_state()

        print "============ Press `Enter` to execute a movement using a pose goal ..."
        raw_input()
        tutorial.go_to_pose_goal()

        print "============ Press `Enter` to Pick ..."
        raw_input()
        tutorial.pick()

        print "============ Press `Enter` to Place ..."
        raw_input()
        tutorial.place()

        # print "============ Press `Enter` to plan and display a Cartesian path ..."
        # raw_input()
        # cartesian_plan, fraction = tutorial.plan_cartesian_path()

        # print "============ Press `Enter` to display a saved trajectory (this will replay the Cartesian path)  ..."
        # raw_input()
        # tutorial.display_trajectory(cartesian_plan)

        # print "============ Press `Enter` to execute a saved path ..."
        # raw_input()
        # tutorial.execute_plan(cartesian_plan)

        # print "============ Press `Enter` to attach a Box to the Panda robot ..."
        # raw_input()
        # tutorial.attach_box()

        # print "============ Press `Enter` to plan and execute a path with an attached collision object ..."
        # raw_input()
        # cartesian_plan, fraction = tutorial.plan_cartesian_path(scale=-1)
        # tutorial.execute_plan(cartesian_plan)

        # print "============ Press `Enter` to detach the box from the Baxter robot ..."
        # raw_input()
        # tutorial.detach_box()

        # print "============ Press `Enter` to remove the box from the planning scene ..."
        # raw_input()
        # tutorial.remove_box()

        # print "============ Python tutorial demo complete!"

        # # print("===========Testing start========")
        # # raw_input()
        # movearm = PickPlace()
        # # print("=========recieve desired position====")
        # # raw_input()

        # movearm.add_box()
        # movearm.compute_cartesian()
        # # # print("========go to standoff position=====")
        # # # raw_input()

        # movearm.move_arm_standoff()
        # # movearm.remove_box()
        # # # print("=====go pickup======")
        # # # raw_input()
        # movearm.move_arm_pick()

        # # movearm.move_arm_pick()
        # # # print("=====go back to standoff=======")
        # # # raw_input()
        # movearm.move_arm_back_standoff()
        # # movearm.add_box()

        # # # print("======go to standoff 2=====")
        # # # raw_input()
        # movearm.move_arm_standoff2()
        # # movearm.remove_box()
        # # # print("=========go place the block====")
        # # # raw_input()
        # movearm.move_arm_place()

        # # # print('========go back to standoff2 ====')
        # # # raw_input()
        # movearm.move_arm_backstandoff2()

        # # # print('====back to initial position=====')

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()