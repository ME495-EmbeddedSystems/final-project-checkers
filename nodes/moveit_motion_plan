#!/usr/bin/env python
""" REFERENCE: https://github.com/ros-planning/moveit_tutorials/blob/master/doc/move_group_python_interface/scripts/move_group_python_interface_tutorial.py
"""

import sys
import copy
import rospy
import numpy as np
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp, PlaceLocation  # For pickplace
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint  # for pickplace
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
from baxter_interface import Gripper, CHECK_VERSION
import tf.transformations as tr


class PickPlace(object):
    def __init__(self):
        rospy.loginfo("Initializing Baxter")
        super(PickPlace, self).__init__()
        # Initialize moveit_commander with kin model
        # and current joint states
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)
        # roscpp_initialize(sys.argv)
        # joint_state_topic = ['joint_states:=/joint_states_desired']
        # moveit_commander.roscpp_initialize(joint_state_topic)
        # moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        # Remote interface for getting, setting and updating
        # robot's belief of surroundings
        self.scene = moveit_commander.PlanningSceneInterface()
        # Interface used to execute motions
        self.move_group = moveit_commander.MoveGroupCommander("right_arm")

        # Display Trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)

        # Getting Basic Information

        # Get robot reference frame name
        self.planning_frame = self.move_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.move_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.group_names)

        # DEBUG: Print Robot State
        self.robot_state = self.robot.get_current_state()
        rospy.loginfo("========== CURRENT STATE: %s" % self.robot_state)

        # Planning and Execurtion parameters
        self.move_group.set_goal_position_tolerance(0.01)
        self.move_group.set_goal_orientation_tolerance(0.01)
        self.move_group.set_planning_time(5.0)
        self.move_group.allow_replanning(True)
        self.move_group.set_max_velocity_scaling_factor(0.6)
        self.move_group.set_max_acceleration_scaling_factor(0.6)

        # State Gripper (L/R)
        self.right_gripper = Gripper('right', CHECK_VERSION)
        # Reboot Gripper
        self.right_gripper.reboot()
        # Calibrate Gripper
        self.right_gripper.calibrate()
        # Open Gripper
        self.right_gripper.open()
        # tutorial.right_gripper.close()

        # Standoff is the amount by which we approach
        # and retreat pre and post grasp
        self.standoff = 0.1

        # z is the z position of the objects we want to grasp
        # hard-coded for now but later will be set in calibration
        self.z = -0.311 + 0.05

        # Initialise attribute for desired EE Pose
        self.pose_goal = Pose()

        # Grasp Message
        self.pick = Grasp()

        # PlaceLocation Message
        self.place = PlaceLocation()

        # Chekcers piece
        # self.puck = CollisionObject()

    def add_box(self, timeout=4):
        """
        """
        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.311
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def attach_box(self, timeout=4):
        box_name = self.box_name
        robot = self.robot
        scene = self.scene
        eef_link = self.eef_link
        group_names = self.group_names
        # Next, we will attach the box to the Panda wrist. Manipulating objects requires the
        # robot be able to touch them without the planning scene reporting the contact as a
        # collision. By adding link names to the ``touch_links`` array, we are telling the
        # planning scene to ignore collisions between those links and the box. For the Panda
        # robot, we set ``grasping_group = 'hand'``. If you are using a different robot,
        # you should change this value to the name of your end effector group name.
        grasping_group = 'right_hand'
        touch_links = robot.get_link_names(group=grasping_group)
        scene.attach_box(eef_link, box_name, touch_links=touch_links)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=True, box_is_known=False, timeout=timeout)

    def detach_box(self, timeout=4):
        box_name = self.box_name
        scene = self.scene
        eef_link = self.eef_link
        # Detaching Objects from the Robot
        # We can also detach and remove the object from the planning scene:
        scene.remove_attached_object(eef_link, name=box_name)
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_known=True, box_is_attached=False, timeout=timeout)

    def remove_box(self, timeout=4):
        box_name = self.box_name
        scene = self.scene
        # We can remove the box from the world.
        scene.remove_world_object(box_name)
        # **Note:** The object must be detached before we can remove it from the world
        # We wait for the planning scene to update.
        # return self.wait_for_state_update(box_is_attached=False, box_is_known=False, timeout=timeout)

    def wait_for_state_update(self,
                              box_is_known=False,
                              box_is_attached=False,
                              timeout=4):
        """ If the Python node dies before publishing a collision object update
            message, the message could get lost and the box will not appear.
            To ensure that the updates are made, we wait until we see the
            changes reflected in the ``get_attached_objects()`` and
            ``get_known_object_names()`` lists.
            For the purpose of this tutorial, we call this function after
            adding, removing, attaching or detaching an object in the planning
            scene. We then wait until the updates have been made or ``timeout``
            seconds have passed
        """

        box_name = self.box_name
        scene = self.scene

        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in scene.get_known_object_names()

        # Test if we are in the expected state
        if (box_is_attached == is_attached) and (box_is_known == is_known):
            return True

        # Sleep so that we give other threads time on the processor
        rospy.sleep(0.1)
        seconds = rospy.get_time()

        # If we exiterd the while loop without returning then we timed out
        return False

    def go_to_pose_goal(self, goal=[0.5, 0.0]):
        move_group = self.move_group
        # Planning to a Pose Goal
        # We can plan a motion for this group to a desired pose for the
        # end-effector:
        pose_goal = Pose()
        # Quaternion from Euler
        quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        # rospy.loginfo("QUATERNION FOUND {}".format(quaternion))
        pose_goal.orientation.x = 1
        pose_goal.orientation.y = 0
        pose_goal.orientation.z = 0
        pose_goal.orientation.w = 0
        pose_goal.position.x = goal[0]
        pose_goal.position.y = goal[1]
        pose_goal.position.z = 0.0

        move_group.set_pose_target(pose_goal)

        # Now, we call the planner to compute the plan and execute it.
        plan = move_group.go(wait=True)
        # Calling `stop()` ensures that there is no residual movement
        move_group.stop()
        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        move_group.clear_pose_targets()
        # For testing:
        # current_pose = self.move_group.get_current_pose().pose

    def pick_routine(self, goal):
        # PRE GRASP GOAL
        pre_grasp_goal = Pose()
        # Always point EE down
        pre_grasp_goal.orientation.x = 1
        pre_grasp_goal.position.x = goal[0]
        pre_grasp_goal.position.y = goal[1]
        # Set approach position w standoff
        pre_grasp_goal.position.z = self.z + self.standoff

        # Now move
        self.move_group.set_pose_target(pre_grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

        # GRASP GOAL
        grasp_goal = Pose()
        # Always point EE down
        grasp_goal.orientation.x = 1
        grasp_goal.position.x = goal[0]
        grasp_goal.position.y = goal[1]
        # Set grasp position w/o standoff
        grasp_goal.position.z = self.z

        # Now move
        self.move_group.set_pose_target(grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        # Close Gripper to grasp
        self.right_gripper.close()

        rospy.sleep(0.5)

        # RETREAT GOAL (same as pre-grasp)
        # Now move
        self.move_group.set_pose_target(pre_grasp_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

    def place_routine(self, goal):
        # PRE PLACE GOAL
        pre_place_goal = Pose()
        # Always point EE down
        pre_place_goal.orientation.x = 1
        pre_place_goal.position.x = goal[0]
        pre_place_goal.position.y = goal[1]
        # Set approach position w standoff
        pre_place_goal.position.z = self.z + self.standoff

        # Now move
        self.move_group.set_pose_target(pre_place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

        # PLACE GOAL
        place_goal = Pose()
        # Always point EE down
        place_goal.orientation.x = 1
        place_goal.position.x = goal[0]
        place_goal.position.y = goal[1]
        # Set grasp position w/o standoff
        place_goal.position.z = self.z

        # Now move
        self.move_group.set_pose_target(place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        # Open Gripper to release
        self.right_gripper.open()

        rospy.sleep(0.5)

        # RETREAT GOAL (same as pre-place)
        # Now move
        self.move_group.set_pose_target(pre_place_goal)
        # Execute and wait until execution is done
        self.move_group.go(wait=True)
        # Stop to ensure no residual movement
        self.move_group.stop()
        # Clear targets after planning
        self.move_group.clear_pose_targets()

        rospy.sleep(0.5)

    def pick_cartesian(self, goal):
        # APPROACH GOAL
        rospy.loginfo("================== Approach ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 20
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z + self.standoff, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

        # GRASP GOAL
        rospy.loginfo("================== Grasp ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 20
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

        # Close Gripper to grasp
        self.right_gripper.close()
        rospy.sleep(0.5)

        # RETREAT GOAL (same as approach)
        rospy.loginfo("================== Retreat ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 10
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z + self.standoff, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

    def place_cartesian(self, goal):
        # APPROACH GOAL
        rospy.loginfo("================== Approach ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 20
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z + self.standoff, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

        # GRASP GOAL
        rospy.loginfo("================== Release ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 20
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

        # Close Gripper to grasp
        self.right_gripper.open()
        rospy.sleep(0.5)

        # RETREAT GOAL (same as approach)
        rospy.loginfo("================== Retreat ==============")
        ee_pose = self.move_group.get_current_pose().pose
        waypoints = []
        iter = 10
        xiter = np.linspace(ee_pose.position.x, goal[0], iter)
        yiter = np.linspace(ee_pose.position.y, goal[1], iter)
        ziter = np.linspace(ee_pose.position.z, self.z + self.standoff, iter)
        for i in range(iter):
            p = copy.deepcopy(ee_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]
            # Point Down
            if i >= iter - 1:
                p.orientation.x = 1
            waypoints.append(p)
        # Now plan and move
        self.plan_cartesian_path(waypoints, goal)
        rospy.sleep(0.5)

    def plan_cartesian_path(self, waypoints, goal):
        # Scale = -1 for python according to tutorial
        # You can plan a Cartesian path by specifying a list of waypoints
        # for the end-effector to go through:
        self.move_group.set_start_state_to_current_state()
        fraction = 0.0
        max_attempts = 50
        attempts = 0

        # Plan the Cartesian path connecting the waypoints
        # We want the Cartesian path to be interpolated at a resolution of 1 cm
        # which is why we will specify 0.01 as the eef_step in Cartesian
        # translation.  Disable jump thresh by setting it to 0.0
        # waypoints to follow, eef_step, jump_threshold
        while fraction <= 0.8 and attempts < max_attempts:
            plan, fraction = self.move_group.compute_cartesian_path(waypoints, 0.01, 0.0)
            # Increment the number of attempts
            attempts += 1
        # If we have a complete plan, execute the trajectory
        if fraction >= 0.8:
            rospy.loginfo("Path computed successfully. Moving the arm.")
            self.move_group.execute(plan, wait=True)

        else:
            rospy.logerr("Could not find valid cartesian path")
            # Go back to start
            self.go_to_pose_goal(goal)

    def pick_cpp(self):
        """ DESCRIPTION

            Args:

            Returns:
        """
        # PICK POSE
        self.pick.grasp_pose.header.frame_id = "base"
        # Quaternion from Euler
        # quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        self.pick.grasp_pose.pose.orientation.x = 1
        self.pick.grasp_pose.pose.orientation.y = 0
        self.pick.grasp_pose.pose.orientation.z = 0
        self.pick.grasp_pose.pose.orientation.w = 0
        self.pick.grasp_pose.pose.position.x = 0.5
        self.pick.grasp_pose.pose.position.y = 0.0
        self.pick.grasp_pose.pose.position.z = -0.3075 + 0.1

        # APPROACH
        # Defined with respect to frame_id
        self.pick.pre_grasp_approach.direction.header.frame_id = "base"
        # Direction in negative z-axis for pre-grasp direction (up)
        self.pick.pre_grasp_approach.direction.vector.z = -1.0
        self.pick.pre_grasp_approach.min_distance = 0.095
        self.pick.pre_grasp_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.pick.post_grasp_retreat.direction.header.frame_id = "base"
        # Direction is set as positive z axis
        self.pick.post_grasp_retreat.direction.vector.z = 1.0
        self.pick.post_grasp_retreat.min_distance = 0.1
        self.pick.post_grasp_retreat.desired_distance = 0.25

        # PRE-GRASP POSTURE: OPEN GRIPPER
        pre_grasp_posture = JointTrajectory()
        pre_grasp_posture.header.frame_id = "base"
        pre_grasp_posture.header.stamp = rospy.Time.now()
        pre_grasp_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(1.0)
        pos.positions.append(1.0)
        pre_grasp_posture.points.append(pos)
        self.pick.pre_grasp_posture = pre_grasp_posture

        # GRASP POSTURE: CLOSE GRIPPER
        grasp_posture = JointTrajectory()
        grasp_posture.header.frame_id = "base"
        grasp_posture.header.stamp = rospy.Time.now()
        grasp_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(0.0)
        pos.positions.append(0.0)
        grasp_posture.points.append(pos)
        self.pick.grasp_posture = pre_grasp_posture

        # Set Support Surface
        # self.move_group.setSupportSurfaceName("table")
        # Perform pick method using grasp vars
        self.move_group.pick("puck", self.pick)

    def place_cpp(self):
        """ DESCRIPTION

            Args:

            Returns:
        """
        # PLACE POSE
        self.place.place_pose.header.frame_id = "base"
        # Quaternion from Euler
        # quaternion = tr.quaternion_from_euler(0, np.pi / 2, 0, 'sxyz')
        self.place.place_pose.pose.orientation.x = 1
        self.place.place_pose.pose.orientation.y = 0
        self.place.place_pose.pose.orientation.z = 0
        self.place.place_pose.pose.orientation.w = 0
        self.place.place_pose.pose.position.x = 0.5
        self.place.place_pose.pose.position.y = 0.0
        self.place.place_pose.pose.position.z = -0.3075 + 0.1

        # APPROACH
        # Defined with respect to frame_id
        self.place.pre_place_approach.direction.header.frame_id = "base"
        # Direction is set as negative z axis
        self.place.pre_place_approach.direction.vector.z = -1.0
        self.place.pre_place_approach.min_distance = 0.095
        self.place.pre_place_approach.desired_distance = 0.115

        # RETREAT
        # Defined with respect to frame_id
        self.place.post_place_retreat.direction.header.frame_id = "base"
        # Direction is set as negative y axis
        self.place.post_place_retreat.direction.vector.y = -1.0
        self.place.post_place_retreat.min_distance = 0.1
        self.place.post_place_retreat.desired_distance = 0.25

        # POST PLACE POSTURE: OPEN GRIPPER
        post_place_posture = JointTrajectory()
        post_place_posture.header.frame_id = "base"
        post_place_posture.header.stamp = rospy.Time.now()
        post_place_posture.joint_names = [
            "r_gripper_l_finger", "r_gripper_r_finger"
        ]
        pos = JointTrajectoryPoint()  # fingers open
        pos.positions.append(0.0)
        pos.positions.append(0.0)
        post_place_posture.points.append(pos)
        self.place.post_place_posture = post_place_posture

        # Set Support Surface
        # self.move_group.setSupportSurfaceName("table")
        # Perform place method using grasp vars
        self.move_group.place("puck", self.place)

    def pp_object(self):
        """
        """
        # Define the object that we will be manipulating
        self.puck_pose = PoseStamped()
        self.puck_name = "puck"

        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.puck_pose.header.frame_id = "base"
        self.puck_pose.pose.position.x = 0.5
        self.puck_pose.pose.position.z = -0.3075 + 0.05
        self.puck_pose.pose.orientation.w = 1.0
        # TODO: Change to Cylinder
        self.scene.add_box(self.puck_name,
                           self.puck_pose,
                           size=(25e-3, 25e-3, 10e-3))

    def open_gripper(self):
        pos_l = JointTrajectory()
        pos_r = JointTrajectory()

        # Names
        pos_l.posture.joint_names = "r_gripper_l_finger"
        pos_r.posture.joint_names = "r_gripper_r_finger"

        # Open
        pos_l.posture.points.positions = 1
        pos_l.posture.points.time_from_start = rospy.Duration(0.5)
        pos_r.posture.points.positions = 1
        pos_r.posture.points.time_from_start = rospy.Duration(0.5)


def main():
    rospy.init_node("moveit_motion_plan", anonymous=True)

    #listen to the topic which is publishing desired cartian coordinate

    # rospy.Subscriber("square-location",String,self.compute_cartesian)

    try:

        print ""
        print "----------------------------------------------------------"
        print "Welcome to the MoveIt MoveGroup Python Interface Tutorial"
        print "----------------------------------------------------------"
        print "Press Ctrl-D to exit at any time"
        print ""
        tutorial = PickPlace()

        print "============ Add a box and checkers piece to the planning scene ..."
        tutorial.add_box()
        # tutorial.pp_object()

        # print "============ Press `Enter` to execute a movement using a joint state goal ..."
        # raw_input()
        # tutorial.go_to_joint_state()

        print "============ Press `Enter` to execute a movement using a pose goal ..."
        raw_input()
        tutorial.go_to_pose_goal()

        print "============ Press `Enter` to Pick ..."
        raw_input()
        tutorial.pick_cartesian([0.59, -0.06])

        print "============ Press `Enter` to Place ..."
        raw_input()
        tutorial.place_cartesian([0.49, -0.06])

        # print "============ Press `Enter` to plan and display a Cartesian path ..."
        # raw_input()
        # cartesian_plan, fraction = tutorial.plan_cartesian_path()

        # print "============ Press `Enter` to display a saved trajectory (this will replay the Cartesian path)  ..."
        # raw_input()
        # tutorial.display_trajectory(cartesian_plan)

        # print "============ Press `Enter` to execute a saved path ..."
        # raw_input()
        # tutorial.execute_plan(cartesian_plan)

        # print "============ Press `Enter` to attach a Box to the Panda robot ..."
        # raw_input()
        # tutorial.attach_box()

        # print "============ Press `Enter` to plan and execute a path with an attached collision object ..."
        # raw_input()
        # cartesian_plan, fraction = tutorial.plan_cartesian_path(scale=-1)
        # tutorial.execute_plan(cartesian_plan)

        # print "============ Press `Enter` to detach the box from the Baxter robot ..."
        # raw_input()
        # tutorial.detach_box()

        # print "============ Press `Enter` to remove the box from the planning scene ..."
        # raw_input()
        # tutorial.remove_box()

        # print "============ Python tutorial demo complete!"

        # # print("===========Testing start========")
        # # raw_input()
        # movearm = PickPlace()
        # # print("=========recieve desired position====")
        # # raw_input()

        # movearm.add_box()
        # movearm.compute_cartesian()
        # # # print("========go to standoff position=====")
        # # # raw_input()

        # movearm.move_arm_standoff()
        # # movearm.remove_box()
        # # # print("=====go pickup======")
        # # # raw_input()
        # movearm.move_arm_pick()

        # # movearm.move_arm_pick()
        # # # print("=====go back to standoff=======")
        # # # raw_input()
        # movearm.move_arm_back_standoff()
        # # movearm.add_box()

        # # # print("======go to standoff 2=====")
        # # # raw_input()
        # movearm.move_arm_standoff2()
        # # movearm.remove_box()
        # # # print("=========go place the block====")
        # # # raw_input()
        # movearm.move_arm_place()

        # # # print('========go back to standoff2 ====')
        # # # raw_input()
        # movearm.move_arm_backstandoff2()

        # # # print('====back to initial position=====')

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()